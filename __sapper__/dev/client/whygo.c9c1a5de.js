import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, t as text, a as space, c as claim_element, b as children, g as claim_text, d as detach, f as claim_space, h as attr, k as insert, l as append, n as noop } from './client.0645f010.js';

/* src/routes/bloggy/whygo.svelte generated by Svelte v3.22.3 */

function create_fragment(ctx) {
	let h3;
	let t0;
	let t1;
	let br0;
	let t2;
	let div;
	let p;
	let t3;
	let br1;
	let t4;
	let t5;
	let pre0;
	let code0;

	let t6_value = `type Guitarist struct{Guitarist } //object
func(m Musician) Run(){} // method
type Musician interface { Run()} //interface that uses the method
` + "";

	let t6;
	let t7;
	let ul;
	let li0;
	let t8;
	let t9;
	let li1;
	let t10;
	let t11;
	let li2;
	let t12;
	let t13;
	let pre1;
	let code1;

	let t14_value = `func Service(Musician){
    fmt.Println(Musician)
}
` + "";

	let t14;
	let t15;

	return {
		c() {
			h3 = element("h3");
			t0 = text("I Love Go because of it's simplicity.");
			t1 = space();
			br0 = element("br");
			t2 = space();
			div = element("div");
			p = element("p");
			t3 = text("What does this mean? I am referring to its api and it's ability to uncouple code.\nWhy is this important? Many developers are bound to the constraints\nto their language and tech stack.  The point is so that when your \nproject gets bigger you are not constrained to what you have already\ncreated.  \n");
			br1 = element("br");
			t4 = text("\nAn example of what I am referring to.");
			t5 = space();
			pre0 = element("pre");
			code0 = element("code");
			t6 = text(t6_value);
			t7 = text("\n\n\nThe three bits of code that are stated are pretty simple.\nbut they are the building blocks to uncoupling code.\n");
			ul = element("ul");
			li0 = element("li");
			t8 = text("1. struct");
			t9 = space();
			li1 = element("li");
			t10 = text("2. method");
			t11 = space();
			li2 = element("li");
			t12 = text("3. interface");
			t13 = text("\n\n\nThese are the components needed to uncouple your code.  \n\nLets say you are building a Service on Musican.\n");
			pre1 = element("pre");
			code1 = element("code");
			t14 = text(t14_value);
			t15 = text("\n\nWe used the interface Musician to allow for any struct with run() to be passed.\nSo if we needed to pass another struct of data in we can.\n\nThis allows for not having to think about your data or concrete data type.\nSomething many languages you are tied to.\n\nI will go further in the next blog about packages and utilizing this method. \n\n.........");
			this.h();
		},
		l(nodes) {
			h3 = claim_element(nodes, "H3", {});
			var h3_nodes = children(h3);
			t0 = claim_text(h3_nodes, "I Love Go because of it's simplicity.");
			h3_nodes.forEach(detach);
			t1 = claim_space(nodes);
			br0 = claim_element(nodes, "BR", {});
			t2 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p = claim_element(div_nodes, "P", {});
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "What does this mean? I am referring to its api and it's ability to uncouple code.\nWhy is this important? Many developers are bound to the constraints\nto their language and tech stack.  The point is so that when your \nproject gets bigger you are not constrained to what you have already\ncreated.  \n");
			br1 = claim_element(p_nodes, "BR", {});
			t4 = claim_text(p_nodes, "\nAn example of what I am referring to.");
			p_nodes.forEach(detach);
			t5 = claim_space(div_nodes);
			pre0 = claim_element(div_nodes, "PRE", { class: true });
			var pre0_nodes = children(pre0);
			code0 = claim_element(pre0_nodes, "CODE", { class: true });
			var code0_nodes = children(code0);
			t6 = claim_text(code0_nodes, t6_value);
			code0_nodes.forEach(detach);
			pre0_nodes.forEach(detach);
			t7 = claim_text(div_nodes, "\n\n\nThe three bits of code that are stated are pretty simple.\nbut they are the building blocks to uncoupling code.\n");
			ul = claim_element(div_nodes, "UL", {});
			var ul_nodes = children(ul);
			li0 = claim_element(ul_nodes, "LI", {});
			var li0_nodes = children(li0);
			t8 = claim_text(li0_nodes, "1. struct");
			li0_nodes.forEach(detach);
			t9 = claim_space(ul_nodes);
			li1 = claim_element(ul_nodes, "LI", {});
			var li1_nodes = children(li1);
			t10 = claim_text(li1_nodes, "2. method");
			li1_nodes.forEach(detach);
			t11 = claim_space(ul_nodes);
			li2 = claim_element(ul_nodes, "LI", {});
			var li2_nodes = children(li2);
			t12 = claim_text(li2_nodes, "3. interface");
			li2_nodes.forEach(detach);
			ul_nodes.forEach(detach);
			t13 = claim_text(div_nodes, "\n\n\nThese are the components needed to uncouple your code.  \n\nLets say you are building a Service on Musican.\n");
			pre1 = claim_element(div_nodes, "PRE", { class: true });
			var pre1_nodes = children(pre1);
			code1 = claim_element(pre1_nodes, "CODE", { class: true });
			var code1_nodes = children(code1);
			t14 = claim_text(code1_nodes, t14_value);
			code1_nodes.forEach(detach);
			pre1_nodes.forEach(detach);
			t15 = claim_text(div_nodes, "\n\nWe used the interface Musician to allow for any struct with run() to be passed.\nSo if we needed to pass another struct of data in we can.\n\nThis allows for not having to think about your data or concrete data type.\nSomething many languages you are tied to.\n\nI will go further in the next blog about packages and utilizing this method. \n\n.........");
			div_nodes.forEach(detach);
			this.h();
		},
		h() {
			attr(code0, "class", "svelte-p8wa68");
			attr(pre0, "class", "svelte-p8wa68");
			attr(code1, "class", "svelte-p8wa68");
			attr(pre1, "class", "svelte-p8wa68");
			attr(div, "class", "body svelte-p8wa68");
		},
		m(target, anchor) {
			insert(target, h3, anchor);
			append(h3, t0);
			insert(target, t1, anchor);
			insert(target, br0, anchor);
			insert(target, t2, anchor);
			insert(target, div, anchor);
			append(div, p);
			append(p, t3);
			append(p, br1);
			append(p, t4);
			append(div, t5);
			append(div, pre0);
			append(pre0, code0);
			append(code0, t6);
			append(div, t7);
			append(div, ul);
			append(ul, li0);
			append(li0, t8);
			append(ul, t9);
			append(ul, li1);
			append(li1, t10);
			append(ul, t11);
			append(ul, li2);
			append(li2, t12);
			append(div, t13);
			append(div, pre1);
			append(pre1, code1);
			append(code1, t14);
			append(div, t15);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(h3);
			if (detaching) detach(t1);
			if (detaching) detach(br0);
			if (detaching) detach(t2);
			if (detaching) detach(div);
		}
	};
}

class Whygo extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, null, create_fragment, safe_not_equal, {});
	}
}

export default Whygo;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2h5Z28uYzljMWE1ZGUuanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
